// source: nuance/tts/v1/nuance_tts_v1.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = (function() { return this || window || global || self || Function('return this')(); }).call(null);

goog.exportSymbol('proto.nuance.tts.v1.ALaw', null, global);
goog.exportSymbol('proto.nuance.tts.v1.AudioFormat', null, global);
goog.exportSymbol('proto.nuance.tts.v1.AudioFormat.AudioFormatCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.AudioParameters', null, global);
goog.exportSymbol('proto.nuance.tts.v1.ControlCode', null, global);
goog.exportSymbol('proto.nuance.tts.v1.DownloadParameters', null, global);
goog.exportSymbol('proto.nuance.tts.v1.DownloadParameters.OptionalDownloadParameterRequestTimeoutMsCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EnumAgeGroup', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EnumGender', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EnumResourceType', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EnumSSMLValidationMode', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EnumVariableBitrate', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Event', null, global);
goog.exportSymbol('proto.nuance.tts.v1.EventParameters', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Events', null, global);
goog.exportSymbol('proto.nuance.tts.v1.GetVoicesRequest', null, global);
goog.exportSymbol('proto.nuance.tts.v1.GetVoicesResponse', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Input', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Input.InputDataCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.LanguageIdentificationParameters', null, global);
goog.exportSymbol('proto.nuance.tts.v1.OggOpus', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Opus', null, global);
goog.exportSymbol('proto.nuance.tts.v1.PCM', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SSML', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SSML.SsmlDataCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Status', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SynthesisRequest', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SynthesisResource', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SynthesisResource.ResourceDataCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SynthesisResponse', null, global);
goog.exportSymbol('proto.nuance.tts.v1.SynthesisResponse.ResponseCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Text', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Text.TextDataCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Token', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Token.TokenDataCase', null, global);
goog.exportSymbol('proto.nuance.tts.v1.TokenizedSequence', null, global);
goog.exportSymbol('proto.nuance.tts.v1.ULaw', null, global);
goog.exportSymbol('proto.nuance.tts.v1.UnarySynthesisResponse', null, global);
goog.exportSymbol('proto.nuance.tts.v1.Voice', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.GetVoicesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.GetVoicesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.GetVoicesRequest.displayName = 'proto.nuance.tts.v1.GetVoicesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.GetVoicesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.GetVoicesResponse.repeatedFields_, null);
};
goog.inherits(proto.nuance.tts.v1.GetVoicesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.GetVoicesResponse.displayName = 'proto.nuance.tts.v1.GetVoicesResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.SynthesisRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.SynthesisRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.SynthesisRequest.displayName = 'proto.nuance.tts.v1.SynthesisRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Voice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.Voice.repeatedFields_, null);
};
goog.inherits(proto.nuance.tts.v1.Voice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Voice.displayName = 'proto.nuance.tts.v1.Voice';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.AudioParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.AudioParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.AudioParameters.displayName = 'proto.nuance.tts.v1.AudioParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.AudioFormat = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.AudioFormat.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.AudioFormat, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.AudioFormat.displayName = 'proto.nuance.tts.v1.AudioFormat';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.PCM = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.PCM, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.PCM.displayName = 'proto.nuance.tts.v1.PCM';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.ALaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.ALaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.ALaw.displayName = 'proto.nuance.tts.v1.ALaw';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.ULaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.ULaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.ULaw.displayName = 'proto.nuance.tts.v1.ULaw';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Opus = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.Opus, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Opus.displayName = 'proto.nuance.tts.v1.Opus';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.OggOpus = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.OggOpus, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.OggOpus.displayName = 'proto.nuance.tts.v1.OggOpus';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.Input.repeatedFields_, proto.nuance.tts.v1.Input.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Input.displayName = 'proto.nuance.tts.v1.Input';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Text = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.Text.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.Text, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Text.displayName = 'proto.nuance.tts.v1.Text';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.SSML = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.SSML.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.SSML, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.SSML.displayName = 'proto.nuance.tts.v1.SSML';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.TokenizedSequence = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.TokenizedSequence.repeatedFields_, null);
};
goog.inherits(proto.nuance.tts.v1.TokenizedSequence, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.TokenizedSequence.displayName = 'proto.nuance.tts.v1.TokenizedSequence';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Token = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.Token.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.Token, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Token.displayName = 'proto.nuance.tts.v1.Token';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.ControlCode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.ControlCode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.ControlCode.displayName = 'proto.nuance.tts.v1.ControlCode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.SynthesisResource = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.SynthesisResource.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.SynthesisResource, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.SynthesisResource.displayName = 'proto.nuance.tts.v1.SynthesisResource';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.LanguageIdentificationParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.LanguageIdentificationParameters.repeatedFields_, null);
};
goog.inherits(proto.nuance.tts.v1.LanguageIdentificationParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.LanguageIdentificationParameters.displayName = 'proto.nuance.tts.v1.LanguageIdentificationParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.DownloadParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.DownloadParameters.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.DownloadParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.DownloadParameters.displayName = 'proto.nuance.tts.v1.DownloadParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.EventParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.EventParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.EventParameters.displayName = 'proto.nuance.tts.v1.EventParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.SynthesisResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_);
};
goog.inherits(proto.nuance.tts.v1.SynthesisResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.SynthesisResponse.displayName = 'proto.nuance.tts.v1.SynthesisResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.UnarySynthesisResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.UnarySynthesisResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.UnarySynthesisResponse.displayName = 'proto.nuance.tts.v1.UnarySynthesisResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Status = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.Status, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Status.displayName = 'proto.nuance.tts.v1.Status';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Events = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nuance.tts.v1.Events.repeatedFields_, null);
};
goog.inherits(proto.nuance.tts.v1.Events, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Events.displayName = 'proto.nuance.tts.v1.Events';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nuance.tts.v1.Event = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nuance.tts.v1.Event, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nuance.tts.v1.Event.displayName = 'proto.nuance.tts.v1.Event';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.GetVoicesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.GetVoicesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.GetVoicesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.GetVoicesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    voice: (f = msg.getVoice()) && proto.nuance.tts.v1.Voice.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.GetVoicesRequest}
 */
proto.nuance.tts.v1.GetVoicesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.GetVoicesRequest;
  return proto.nuance.tts.v1.GetVoicesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.GetVoicesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.GetVoicesRequest}
 */
proto.nuance.tts.v1.GetVoicesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Voice;
      reader.readMessage(value,proto.nuance.tts.v1.Voice.deserializeBinaryFromReader);
      msg.setVoice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.GetVoicesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.GetVoicesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.GetVoicesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.GetVoicesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVoice();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.Voice.serializeBinaryToWriter
    );
  }
};


/**
 * optional Voice voice = 1;
 * @return {?proto.nuance.tts.v1.Voice}
 */
proto.nuance.tts.v1.GetVoicesRequest.prototype.getVoice = function() {
  return /** @type{?proto.nuance.tts.v1.Voice} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Voice, 1));
};


/**
 * @param {?proto.nuance.tts.v1.Voice|undefined} value
 * @return {!proto.nuance.tts.v1.GetVoicesRequest} returns this
*/
proto.nuance.tts.v1.GetVoicesRequest.prototype.setVoice = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.GetVoicesRequest} returns this
 */
proto.nuance.tts.v1.GetVoicesRequest.prototype.clearVoice = function() {
  return this.setVoice(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.GetVoicesRequest.prototype.hasVoice = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.GetVoicesResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.GetVoicesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.GetVoicesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.GetVoicesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.GetVoicesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    voicesList: jspb.Message.toObjectList(msg.getVoicesList(),
    proto.nuance.tts.v1.Voice.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.GetVoicesResponse}
 */
proto.nuance.tts.v1.GetVoicesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.GetVoicesResponse;
  return proto.nuance.tts.v1.GetVoicesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.GetVoicesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.GetVoicesResponse}
 */
proto.nuance.tts.v1.GetVoicesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Voice;
      reader.readMessage(value,proto.nuance.tts.v1.Voice.deserializeBinaryFromReader);
      msg.addVoices(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.GetVoicesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.GetVoicesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.GetVoicesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.GetVoicesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.nuance.tts.v1.Voice.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Voice voices = 1;
 * @return {!Array<!proto.nuance.tts.v1.Voice>}
 */
proto.nuance.tts.v1.GetVoicesResponse.prototype.getVoicesList = function() {
  return /** @type{!Array<!proto.nuance.tts.v1.Voice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nuance.tts.v1.Voice, 1));
};


/**
 * @param {!Array<!proto.nuance.tts.v1.Voice>} value
 * @return {!proto.nuance.tts.v1.GetVoicesResponse} returns this
*/
proto.nuance.tts.v1.GetVoicesResponse.prototype.setVoicesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.nuance.tts.v1.Voice=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.Voice}
 */
proto.nuance.tts.v1.GetVoicesResponse.prototype.addVoices = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.nuance.tts.v1.Voice, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.GetVoicesResponse} returns this
 */
proto.nuance.tts.v1.GetVoicesResponse.prototype.clearVoicesList = function() {
  return this.setVoicesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.SynthesisRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.SynthesisRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    voice: (f = msg.getVoice()) && proto.nuance.tts.v1.Voice.toObject(includeInstance, f),
    audioParams: (f = msg.getAudioParams()) && proto.nuance.tts.v1.AudioParameters.toObject(includeInstance, f),
    input: (f = msg.getInput()) && proto.nuance.tts.v1.Input.toObject(includeInstance, f),
    eventParams: (f = msg.getEventParams()) && proto.nuance.tts.v1.EventParameters.toObject(includeInstance, f),
    clientDataMap: (f = msg.getClientDataMap()) ? f.toObject(includeInstance, undefined) : [],
    userId: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.SynthesisRequest}
 */
proto.nuance.tts.v1.SynthesisRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.SynthesisRequest;
  return proto.nuance.tts.v1.SynthesisRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.SynthesisRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.SynthesisRequest}
 */
proto.nuance.tts.v1.SynthesisRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Voice;
      reader.readMessage(value,proto.nuance.tts.v1.Voice.deserializeBinaryFromReader);
      msg.setVoice(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.AudioParameters;
      reader.readMessage(value,proto.nuance.tts.v1.AudioParameters.deserializeBinaryFromReader);
      msg.setAudioParams(value);
      break;
    case 3:
      var value = new proto.nuance.tts.v1.Input;
      reader.readMessage(value,proto.nuance.tts.v1.Input.deserializeBinaryFromReader);
      msg.setInput(value);
      break;
    case 4:
      var value = new proto.nuance.tts.v1.EventParameters;
      reader.readMessage(value,proto.nuance.tts.v1.EventParameters.deserializeBinaryFromReader);
      msg.setEventParams(value);
      break;
    case 5:
      var value = msg.getClientDataMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.SynthesisRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.SynthesisRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVoice();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.Voice.serializeBinaryToWriter
    );
  }
  f = message.getAudioParams();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.AudioParameters.serializeBinaryToWriter
    );
  }
  f = message.getInput();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.nuance.tts.v1.Input.serializeBinaryToWriter
    );
  }
  f = message.getEventParams();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.nuance.tts.v1.EventParameters.serializeBinaryToWriter
    );
  }
  f = message.getClientDataMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getUserId();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional Voice voice = 1;
 * @return {?proto.nuance.tts.v1.Voice}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getVoice = function() {
  return /** @type{?proto.nuance.tts.v1.Voice} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Voice, 1));
};


/**
 * @param {?proto.nuance.tts.v1.Voice|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
*/
proto.nuance.tts.v1.SynthesisRequest.prototype.setVoice = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.clearVoice = function() {
  return this.setVoice(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.hasVoice = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional AudioParameters audio_params = 2;
 * @return {?proto.nuance.tts.v1.AudioParameters}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getAudioParams = function() {
  return /** @type{?proto.nuance.tts.v1.AudioParameters} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.AudioParameters, 2));
};


/**
 * @param {?proto.nuance.tts.v1.AudioParameters|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
*/
proto.nuance.tts.v1.SynthesisRequest.prototype.setAudioParams = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.clearAudioParams = function() {
  return this.setAudioParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.hasAudioParams = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Input input = 3;
 * @return {?proto.nuance.tts.v1.Input}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getInput = function() {
  return /** @type{?proto.nuance.tts.v1.Input} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Input, 3));
};


/**
 * @param {?proto.nuance.tts.v1.Input|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
*/
proto.nuance.tts.v1.SynthesisRequest.prototype.setInput = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.clearInput = function() {
  return this.setInput(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.hasInput = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional EventParameters event_params = 4;
 * @return {?proto.nuance.tts.v1.EventParameters}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getEventParams = function() {
  return /** @type{?proto.nuance.tts.v1.EventParameters} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.EventParameters, 4));
};


/**
 * @param {?proto.nuance.tts.v1.EventParameters|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
*/
proto.nuance.tts.v1.SynthesisRequest.prototype.setEventParams = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.clearEventParams = function() {
  return this.setEventParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.hasEventParams = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * map<string, string> client_data = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getClientDataMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 5, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.clearClientDataMap = function() {
  this.getClientDataMap().clear();
  return this;};


/**
 * optional string user_id = 6;
 * @return {string}
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.getUserId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.SynthesisRequest} returns this
 */
proto.nuance.tts.v1.SynthesisRequest.prototype.setUserId = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.Voice.repeatedFields_ = [10];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Voice.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Voice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Voice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Voice.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
    model: jspb.Message.getFieldWithDefault(msg, 2, ""),
    language: jspb.Message.getFieldWithDefault(msg, 3, ""),
    ageGroup: jspb.Message.getFieldWithDefault(msg, 4, 0),
    gender: jspb.Message.getFieldWithDefault(msg, 5, 0),
    sampleRateHz: jspb.Message.getFieldWithDefault(msg, 6, 0),
    languageTlw: jspb.Message.getFieldWithDefault(msg, 7, ""),
    restricted: jspb.Message.getBooleanFieldWithDefault(msg, 8, false),
    version: jspb.Message.getFieldWithDefault(msg, 9, ""),
    foreignLanguagesList: (f = jspb.Message.getRepeatedField(msg, 10)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Voice}
 */
proto.nuance.tts.v1.Voice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Voice;
  return proto.nuance.tts.v1.Voice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Voice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Voice}
 */
proto.nuance.tts.v1.Voice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setModel(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 4:
      var value = /** @type {!proto.nuance.tts.v1.EnumAgeGroup} */ (reader.readEnum());
      msg.setAgeGroup(value);
      break;
    case 5:
      var value = /** @type {!proto.nuance.tts.v1.EnumGender} */ (reader.readEnum());
      msg.setGender(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSampleRateHz(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguageTlw(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRestricted(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersion(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.addForeignLanguages(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Voice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Voice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Voice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Voice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getModel();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getLanguage();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAgeGroup();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getGender();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getSampleRateHz();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getLanguageTlw();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getRestricted();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getVersion();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
  f = message.getForeignLanguagesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      10,
      f
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nuance.tts.v1.Voice.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string model = 2;
 * @return {string}
 */
proto.nuance.tts.v1.Voice.prototype.getModel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setModel = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string language = 3;
 * @return {string}
 */
proto.nuance.tts.v1.Voice.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setLanguage = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional EnumAgeGroup age_group = 4;
 * @return {!proto.nuance.tts.v1.EnumAgeGroup}
 */
proto.nuance.tts.v1.Voice.prototype.getAgeGroup = function() {
  return /** @type {!proto.nuance.tts.v1.EnumAgeGroup} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumAgeGroup} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setAgeGroup = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional EnumGender gender = 5;
 * @return {!proto.nuance.tts.v1.EnumGender}
 */
proto.nuance.tts.v1.Voice.prototype.getGender = function() {
  return /** @type {!proto.nuance.tts.v1.EnumGender} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumGender} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setGender = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};


/**
 * optional uint32 sample_rate_hz = 6;
 * @return {number}
 */
proto.nuance.tts.v1.Voice.prototype.getSampleRateHz = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setSampleRateHz = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional string language_tlw = 7;
 * @return {string}
 */
proto.nuance.tts.v1.Voice.prototype.getLanguageTlw = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setLanguageTlw = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional bool restricted = 8;
 * @return {boolean}
 */
proto.nuance.tts.v1.Voice.prototype.getRestricted = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 8, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setRestricted = function(value) {
  return jspb.Message.setProto3BooleanField(this, 8, value);
};


/**
 * optional string version = 9;
 * @return {string}
 */
proto.nuance.tts.v1.Voice.prototype.getVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setVersion = function(value) {
  return jspb.Message.setProto3StringField(this, 9, value);
};


/**
 * repeated string foreign_languages = 10;
 * @return {!Array<string>}
 */
proto.nuance.tts.v1.Voice.prototype.getForeignLanguagesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 10));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.setForeignLanguagesList = function(value) {
  return jspb.Message.setField(this, 10, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.addForeignLanguages = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 10, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.Voice} returns this
 */
proto.nuance.tts.v1.Voice.prototype.clearForeignLanguagesList = function() {
  return this.setForeignLanguagesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.AudioParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.AudioParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.AudioParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.AudioParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    audioFormat: (f = msg.getAudioFormat()) && proto.nuance.tts.v1.AudioFormat.toObject(includeInstance, f),
    volumePercentage: jspb.Message.getFieldWithDefault(msg, 2, 0),
    speakingRateFactor: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0),
    audioChunkDurationMs: jspb.Message.getFieldWithDefault(msg, 4, 0),
    targetAudioLengthMs: jspb.Message.getFieldWithDefault(msg, 5, 0),
    disableEarlyEmission: jspb.Message.getBooleanFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.AudioParameters}
 */
proto.nuance.tts.v1.AudioParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.AudioParameters;
  return proto.nuance.tts.v1.AudioParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.AudioParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.AudioParameters}
 */
proto.nuance.tts.v1.AudioParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.AudioFormat;
      reader.readMessage(value,proto.nuance.tts.v1.AudioFormat.deserializeBinaryFromReader);
      msg.setAudioFormat(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVolumePercentage(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSpeakingRateFactor(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAudioChunkDurationMs(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTargetAudioLengthMs(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisableEarlyEmission(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.AudioParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.AudioParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.AudioParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.AudioParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAudioFormat();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.AudioFormat.serializeBinaryToWriter
    );
  }
  f = message.getVolumePercentage();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getSpeakingRateFactor();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = message.getAudioChunkDurationMs();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getTargetAudioLengthMs();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getDisableEarlyEmission();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional AudioFormat audio_format = 1;
 * @return {?proto.nuance.tts.v1.AudioFormat}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getAudioFormat = function() {
  return /** @type{?proto.nuance.tts.v1.AudioFormat} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.AudioFormat, 1));
};


/**
 * @param {?proto.nuance.tts.v1.AudioFormat|undefined} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
*/
proto.nuance.tts.v1.AudioParameters.prototype.setAudioFormat = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.clearAudioFormat = function() {
  return this.setAudioFormat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioParameters.prototype.hasAudioFormat = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 volume_percentage = 2;
 * @return {number}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getVolumePercentage = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.setVolumePercentage = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional float speaking_rate_factor = 3;
 * @return {number}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getSpeakingRateFactor = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.setSpeakingRateFactor = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional uint32 audio_chunk_duration_ms = 4;
 * @return {number}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getAudioChunkDurationMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.setAudioChunkDurationMs = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint32 target_audio_length_ms = 5;
 * @return {number}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getTargetAudioLengthMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.setTargetAudioLengthMs = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional bool disable_early_emission = 6;
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioParameters.prototype.getDisableEarlyEmission = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 6, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.AudioParameters} returns this
 */
proto.nuance.tts.v1.AudioParameters.prototype.setDisableEarlyEmission = function(value) {
  return jspb.Message.setProto3BooleanField(this, 6, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.AudioFormat.oneofGroups_ = [[1,2,3,4,5]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.AudioFormat.AudioFormatCase = {
  AUDIO_FORMAT_NOT_SET: 0,
  PCM: 1,
  ALAW: 2,
  ULAW: 3,
  OGG_OPUS: 4,
  OPUS: 5
};

/**
 * @return {proto.nuance.tts.v1.AudioFormat.AudioFormatCase}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getAudioFormatCase = function() {
  return /** @type {proto.nuance.tts.v1.AudioFormat.AudioFormatCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.AudioFormat.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.AudioFormat.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.AudioFormat} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.AudioFormat.toObject = function(includeInstance, msg) {
  var f, obj = {
    pcm: (f = msg.getPcm()) && proto.nuance.tts.v1.PCM.toObject(includeInstance, f),
    alaw: (f = msg.getAlaw()) && proto.nuance.tts.v1.ALaw.toObject(includeInstance, f),
    ulaw: (f = msg.getUlaw()) && proto.nuance.tts.v1.ULaw.toObject(includeInstance, f),
    oggOpus: (f = msg.getOggOpus()) && proto.nuance.tts.v1.OggOpus.toObject(includeInstance, f),
    opus: (f = msg.getOpus()) && proto.nuance.tts.v1.Opus.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.AudioFormat}
 */
proto.nuance.tts.v1.AudioFormat.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.AudioFormat;
  return proto.nuance.tts.v1.AudioFormat.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.AudioFormat} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.AudioFormat}
 */
proto.nuance.tts.v1.AudioFormat.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.PCM;
      reader.readMessage(value,proto.nuance.tts.v1.PCM.deserializeBinaryFromReader);
      msg.setPcm(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.ALaw;
      reader.readMessage(value,proto.nuance.tts.v1.ALaw.deserializeBinaryFromReader);
      msg.setAlaw(value);
      break;
    case 3:
      var value = new proto.nuance.tts.v1.ULaw;
      reader.readMessage(value,proto.nuance.tts.v1.ULaw.deserializeBinaryFromReader);
      msg.setUlaw(value);
      break;
    case 4:
      var value = new proto.nuance.tts.v1.OggOpus;
      reader.readMessage(value,proto.nuance.tts.v1.OggOpus.deserializeBinaryFromReader);
      msg.setOggOpus(value);
      break;
    case 5:
      var value = new proto.nuance.tts.v1.Opus;
      reader.readMessage(value,proto.nuance.tts.v1.Opus.deserializeBinaryFromReader);
      msg.setOpus(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.AudioFormat.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.AudioFormat.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.AudioFormat} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.AudioFormat.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPcm();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.PCM.serializeBinaryToWriter
    );
  }
  f = message.getAlaw();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.ALaw.serializeBinaryToWriter
    );
  }
  f = message.getUlaw();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.nuance.tts.v1.ULaw.serializeBinaryToWriter
    );
  }
  f = message.getOggOpus();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.nuance.tts.v1.OggOpus.serializeBinaryToWriter
    );
  }
  f = message.getOpus();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.nuance.tts.v1.Opus.serializeBinaryToWriter
    );
  }
};


/**
 * optional PCM pcm = 1;
 * @return {?proto.nuance.tts.v1.PCM}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getPcm = function() {
  return /** @type{?proto.nuance.tts.v1.PCM} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.PCM, 1));
};


/**
 * @param {?proto.nuance.tts.v1.PCM|undefined} value
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
*/
proto.nuance.tts.v1.AudioFormat.prototype.setPcm = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
 */
proto.nuance.tts.v1.AudioFormat.prototype.clearPcm = function() {
  return this.setPcm(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioFormat.prototype.hasPcm = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ALaw alaw = 2;
 * @return {?proto.nuance.tts.v1.ALaw}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getAlaw = function() {
  return /** @type{?proto.nuance.tts.v1.ALaw} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.ALaw, 2));
};


/**
 * @param {?proto.nuance.tts.v1.ALaw|undefined} value
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
*/
proto.nuance.tts.v1.AudioFormat.prototype.setAlaw = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
 */
proto.nuance.tts.v1.AudioFormat.prototype.clearAlaw = function() {
  return this.setAlaw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioFormat.prototype.hasAlaw = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ULaw ulaw = 3;
 * @return {?proto.nuance.tts.v1.ULaw}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getUlaw = function() {
  return /** @type{?proto.nuance.tts.v1.ULaw} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.ULaw, 3));
};


/**
 * @param {?proto.nuance.tts.v1.ULaw|undefined} value
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
*/
proto.nuance.tts.v1.AudioFormat.prototype.setUlaw = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
 */
proto.nuance.tts.v1.AudioFormat.prototype.clearUlaw = function() {
  return this.setUlaw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioFormat.prototype.hasUlaw = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional OggOpus ogg_opus = 4;
 * @return {?proto.nuance.tts.v1.OggOpus}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getOggOpus = function() {
  return /** @type{?proto.nuance.tts.v1.OggOpus} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.OggOpus, 4));
};


/**
 * @param {?proto.nuance.tts.v1.OggOpus|undefined} value
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
*/
proto.nuance.tts.v1.AudioFormat.prototype.setOggOpus = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
 */
proto.nuance.tts.v1.AudioFormat.prototype.clearOggOpus = function() {
  return this.setOggOpus(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioFormat.prototype.hasOggOpus = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Opus opus = 5;
 * @return {?proto.nuance.tts.v1.Opus}
 */
proto.nuance.tts.v1.AudioFormat.prototype.getOpus = function() {
  return /** @type{?proto.nuance.tts.v1.Opus} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Opus, 5));
};


/**
 * @param {?proto.nuance.tts.v1.Opus|undefined} value
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
*/
proto.nuance.tts.v1.AudioFormat.prototype.setOpus = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.nuance.tts.v1.AudioFormat.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.AudioFormat} returns this
 */
proto.nuance.tts.v1.AudioFormat.prototype.clearOpus = function() {
  return this.setOpus(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.AudioFormat.prototype.hasOpus = function() {
  return jspb.Message.getField(this, 5) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.PCM.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.PCM.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.PCM} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.PCM.toObject = function(includeInstance, msg) {
  var f, obj = {
    sampleRateHz: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.PCM}
 */
proto.nuance.tts.v1.PCM.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.PCM;
  return proto.nuance.tts.v1.PCM.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.PCM} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.PCM}
 */
proto.nuance.tts.v1.PCM.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSampleRateHz(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.PCM.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.PCM.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.PCM} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.PCM.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSampleRateHz();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 sample_rate_hz = 1;
 * @return {number}
 */
proto.nuance.tts.v1.PCM.prototype.getSampleRateHz = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.PCM} returns this
 */
proto.nuance.tts.v1.PCM.prototype.setSampleRateHz = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.ALaw.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.ALaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.ALaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ALaw.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.ALaw}
 */
proto.nuance.tts.v1.ALaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.ALaw;
  return proto.nuance.tts.v1.ALaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.ALaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.ALaw}
 */
proto.nuance.tts.v1.ALaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.ALaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.ALaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.ALaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ALaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.ULaw.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.ULaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.ULaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ULaw.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.ULaw}
 */
proto.nuance.tts.v1.ULaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.ULaw;
  return proto.nuance.tts.v1.ULaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.ULaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.ULaw}
 */
proto.nuance.tts.v1.ULaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.ULaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.ULaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.ULaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ULaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Opus.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Opus.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Opus} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Opus.toObject = function(includeInstance, msg) {
  var f, obj = {
    sampleRateHz: jspb.Message.getFieldWithDefault(msg, 1, 0),
    bitRateBps: jspb.Message.getFieldWithDefault(msg, 2, 0),
    maxFrameDurationMs: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0),
    complexity: jspb.Message.getFieldWithDefault(msg, 4, 0),
    vbr: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Opus}
 */
proto.nuance.tts.v1.Opus.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Opus;
  return proto.nuance.tts.v1.Opus.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Opus} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Opus}
 */
proto.nuance.tts.v1.Opus.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSampleRateHz(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBitRateBps(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMaxFrameDurationMs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setComplexity(value);
      break;
    case 5:
      var value = /** @type {!proto.nuance.tts.v1.EnumVariableBitrate} */ (reader.readEnum());
      msg.setVbr(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Opus.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Opus.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Opus} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Opus.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSampleRateHz();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getBitRateBps();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getMaxFrameDurationMs();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = message.getComplexity();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getVbr();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * optional uint32 sample_rate_hz = 1;
 * @return {number}
 */
proto.nuance.tts.v1.Opus.prototype.getSampleRateHz = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Opus} returns this
 */
proto.nuance.tts.v1.Opus.prototype.setSampleRateHz = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 bit_rate_bps = 2;
 * @return {number}
 */
proto.nuance.tts.v1.Opus.prototype.getBitRateBps = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Opus} returns this
 */
proto.nuance.tts.v1.Opus.prototype.setBitRateBps = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional float max_frame_duration_ms = 3;
 * @return {number}
 */
proto.nuance.tts.v1.Opus.prototype.getMaxFrameDurationMs = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Opus} returns this
 */
proto.nuance.tts.v1.Opus.prototype.setMaxFrameDurationMs = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional uint32 complexity = 4;
 * @return {number}
 */
proto.nuance.tts.v1.Opus.prototype.getComplexity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Opus} returns this
 */
proto.nuance.tts.v1.Opus.prototype.setComplexity = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional EnumVariableBitrate vbr = 5;
 * @return {!proto.nuance.tts.v1.EnumVariableBitrate}
 */
proto.nuance.tts.v1.Opus.prototype.getVbr = function() {
  return /** @type {!proto.nuance.tts.v1.EnumVariableBitrate} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumVariableBitrate} value
 * @return {!proto.nuance.tts.v1.Opus} returns this
 */
proto.nuance.tts.v1.Opus.prototype.setVbr = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.OggOpus.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.OggOpus.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.OggOpus} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.OggOpus.toObject = function(includeInstance, msg) {
  var f, obj = {
    sampleRateHz: jspb.Message.getFieldWithDefault(msg, 1, 0),
    bitRateBps: jspb.Message.getFieldWithDefault(msg, 2, 0),
    maxFrameDurationMs: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0),
    complexity: jspb.Message.getFieldWithDefault(msg, 4, 0),
    vbr: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.OggOpus}
 */
proto.nuance.tts.v1.OggOpus.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.OggOpus;
  return proto.nuance.tts.v1.OggOpus.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.OggOpus} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.OggOpus}
 */
proto.nuance.tts.v1.OggOpus.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSampleRateHz(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBitRateBps(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMaxFrameDurationMs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setComplexity(value);
      break;
    case 5:
      var value = /** @type {!proto.nuance.tts.v1.EnumVariableBitrate} */ (reader.readEnum());
      msg.setVbr(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.OggOpus.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.OggOpus.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.OggOpus} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.OggOpus.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSampleRateHz();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getBitRateBps();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getMaxFrameDurationMs();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = message.getComplexity();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getVbr();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * optional uint32 sample_rate_hz = 1;
 * @return {number}
 */
proto.nuance.tts.v1.OggOpus.prototype.getSampleRateHz = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.OggOpus} returns this
 */
proto.nuance.tts.v1.OggOpus.prototype.setSampleRateHz = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 bit_rate_bps = 2;
 * @return {number}
 */
proto.nuance.tts.v1.OggOpus.prototype.getBitRateBps = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.OggOpus} returns this
 */
proto.nuance.tts.v1.OggOpus.prototype.setBitRateBps = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional float max_frame_duration_ms = 3;
 * @return {number}
 */
proto.nuance.tts.v1.OggOpus.prototype.getMaxFrameDurationMs = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.OggOpus} returns this
 */
proto.nuance.tts.v1.OggOpus.prototype.setMaxFrameDurationMs = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional uint32 complexity = 4;
 * @return {number}
 */
proto.nuance.tts.v1.OggOpus.prototype.getComplexity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.OggOpus} returns this
 */
proto.nuance.tts.v1.OggOpus.prototype.setComplexity = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional EnumVariableBitrate vbr = 5;
 * @return {!proto.nuance.tts.v1.EnumVariableBitrate}
 */
proto.nuance.tts.v1.OggOpus.prototype.getVbr = function() {
  return /** @type {!proto.nuance.tts.v1.EnumVariableBitrate} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumVariableBitrate} value
 * @return {!proto.nuance.tts.v1.OggOpus} returns this
 */
proto.nuance.tts.v1.OggOpus.prototype.setVbr = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.Input.repeatedFields_ = [4];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.Input.oneofGroups_ = [[1,2,3]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.Input.InputDataCase = {
  INPUT_DATA_NOT_SET: 0,
  TEXT: 1,
  SSML: 2,
  TOKENIZED_SEQUENCE: 3
};

/**
 * @return {proto.nuance.tts.v1.Input.InputDataCase}
 */
proto.nuance.tts.v1.Input.prototype.getInputDataCase = function() {
  return /** @type {proto.nuance.tts.v1.Input.InputDataCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.Input.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Input} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    text: (f = msg.getText()) && proto.nuance.tts.v1.Text.toObject(includeInstance, f),
    ssml: (f = msg.getSsml()) && proto.nuance.tts.v1.SSML.toObject(includeInstance, f),
    tokenizedSequence: (f = msg.getTokenizedSequence()) && proto.nuance.tts.v1.TokenizedSequence.toObject(includeInstance, f),
    resourcesList: jspb.Message.toObjectList(msg.getResourcesList(),
    proto.nuance.tts.v1.SynthesisResource.toObject, includeInstance),
    lidParams: (f = msg.getLidParams()) && proto.nuance.tts.v1.LanguageIdentificationParameters.toObject(includeInstance, f),
    downloadParams: (f = msg.getDownloadParams()) && proto.nuance.tts.v1.DownloadParameters.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Input}
 */
proto.nuance.tts.v1.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Input;
  return proto.nuance.tts.v1.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Input}
 */
proto.nuance.tts.v1.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Text;
      reader.readMessage(value,proto.nuance.tts.v1.Text.deserializeBinaryFromReader);
      msg.setText(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.SSML;
      reader.readMessage(value,proto.nuance.tts.v1.SSML.deserializeBinaryFromReader);
      msg.setSsml(value);
      break;
    case 3:
      var value = new proto.nuance.tts.v1.TokenizedSequence;
      reader.readMessage(value,proto.nuance.tts.v1.TokenizedSequence.deserializeBinaryFromReader);
      msg.setTokenizedSequence(value);
      break;
    case 4:
      var value = new proto.nuance.tts.v1.SynthesisResource;
      reader.readMessage(value,proto.nuance.tts.v1.SynthesisResource.deserializeBinaryFromReader);
      msg.addResources(value);
      break;
    case 5:
      var value = new proto.nuance.tts.v1.LanguageIdentificationParameters;
      reader.readMessage(value,proto.nuance.tts.v1.LanguageIdentificationParameters.deserializeBinaryFromReader);
      msg.setLidParams(value);
      break;
    case 6:
      var value = new proto.nuance.tts.v1.DownloadParameters;
      reader.readMessage(value,proto.nuance.tts.v1.DownloadParameters.deserializeBinaryFromReader);
      msg.setDownloadParams(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Input.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Input} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Input.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getText();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.Text.serializeBinaryToWriter
    );
  }
  f = message.getSsml();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.SSML.serializeBinaryToWriter
    );
  }
  f = message.getTokenizedSequence();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.nuance.tts.v1.TokenizedSequence.serializeBinaryToWriter
    );
  }
  f = message.getResourcesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.nuance.tts.v1.SynthesisResource.serializeBinaryToWriter
    );
  }
  f = message.getLidParams();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.nuance.tts.v1.LanguageIdentificationParameters.serializeBinaryToWriter
    );
  }
  f = message.getDownloadParams();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.nuance.tts.v1.DownloadParameters.serializeBinaryToWriter
    );
  }
};


/**
 * optional Text text = 1;
 * @return {?proto.nuance.tts.v1.Text}
 */
proto.nuance.tts.v1.Input.prototype.getText = function() {
  return /** @type{?proto.nuance.tts.v1.Text} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Text, 1));
};


/**
 * @param {?proto.nuance.tts.v1.Text|undefined} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setText = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.nuance.tts.v1.Input.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearText = function() {
  return this.setText(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Input.prototype.hasText = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional SSML ssml = 2;
 * @return {?proto.nuance.tts.v1.SSML}
 */
proto.nuance.tts.v1.Input.prototype.getSsml = function() {
  return /** @type{?proto.nuance.tts.v1.SSML} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.SSML, 2));
};


/**
 * @param {?proto.nuance.tts.v1.SSML|undefined} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setSsml = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.nuance.tts.v1.Input.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearSsml = function() {
  return this.setSsml(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Input.prototype.hasSsml = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TokenizedSequence tokenized_sequence = 3;
 * @return {?proto.nuance.tts.v1.TokenizedSequence}
 */
proto.nuance.tts.v1.Input.prototype.getTokenizedSequence = function() {
  return /** @type{?proto.nuance.tts.v1.TokenizedSequence} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.TokenizedSequence, 3));
};


/**
 * @param {?proto.nuance.tts.v1.TokenizedSequence|undefined} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setTokenizedSequence = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.nuance.tts.v1.Input.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearTokenizedSequence = function() {
  return this.setTokenizedSequence(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Input.prototype.hasTokenizedSequence = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated SynthesisResource resources = 4;
 * @return {!Array<!proto.nuance.tts.v1.SynthesisResource>}
 */
proto.nuance.tts.v1.Input.prototype.getResourcesList = function() {
  return /** @type{!Array<!proto.nuance.tts.v1.SynthesisResource>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nuance.tts.v1.SynthesisResource, 4));
};


/**
 * @param {!Array<!proto.nuance.tts.v1.SynthesisResource>} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setResourcesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.nuance.tts.v1.SynthesisResource=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.SynthesisResource}
 */
proto.nuance.tts.v1.Input.prototype.addResources = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.nuance.tts.v1.SynthesisResource, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearResourcesList = function() {
  return this.setResourcesList([]);
};


/**
 * optional LanguageIdentificationParameters lid_params = 5;
 * @return {?proto.nuance.tts.v1.LanguageIdentificationParameters}
 */
proto.nuance.tts.v1.Input.prototype.getLidParams = function() {
  return /** @type{?proto.nuance.tts.v1.LanguageIdentificationParameters} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.LanguageIdentificationParameters, 5));
};


/**
 * @param {?proto.nuance.tts.v1.LanguageIdentificationParameters|undefined} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setLidParams = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearLidParams = function() {
  return this.setLidParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Input.prototype.hasLidParams = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional DownloadParameters download_params = 6;
 * @return {?proto.nuance.tts.v1.DownloadParameters}
 */
proto.nuance.tts.v1.Input.prototype.getDownloadParams = function() {
  return /** @type{?proto.nuance.tts.v1.DownloadParameters} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.DownloadParameters, 6));
};


/**
 * @param {?proto.nuance.tts.v1.DownloadParameters|undefined} value
 * @return {!proto.nuance.tts.v1.Input} returns this
*/
proto.nuance.tts.v1.Input.prototype.setDownloadParams = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Input} returns this
 */
proto.nuance.tts.v1.Input.prototype.clearDownloadParams = function() {
  return this.setDownloadParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Input.prototype.hasDownloadParams = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.Text.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.Text.TextDataCase = {
  TEXT_DATA_NOT_SET: 0,
  TEXT: 1,
  URI: 2
};

/**
 * @return {proto.nuance.tts.v1.Text.TextDataCase}
 */
proto.nuance.tts.v1.Text.prototype.getTextDataCase = function() {
  return /** @type {proto.nuance.tts.v1.Text.TextDataCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.Text.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Text.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Text.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Text} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Text.toObject = function(includeInstance, msg) {
  var f, obj = {
    text: jspb.Message.getFieldWithDefault(msg, 1, ""),
    uri: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Text}
 */
proto.nuance.tts.v1.Text.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Text;
  return proto.nuance.tts.v1.Text.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Text} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Text}
 */
proto.nuance.tts.v1.Text.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUri(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Text.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Text.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Text} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Text.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string text = 1;
 * @return {string}
 */
proto.nuance.tts.v1.Text.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Text} returns this
 */
proto.nuance.tts.v1.Text.prototype.setText = function(value) {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.Text.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.Text} returns this
 */
proto.nuance.tts.v1.Text.prototype.clearText = function() {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.Text.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Text.prototype.hasText = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string uri = 2;
 * @return {string}
 */
proto.nuance.tts.v1.Text.prototype.getUri = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Text} returns this
 */
proto.nuance.tts.v1.Text.prototype.setUri = function(value) {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.Text.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.Text} returns this
 */
proto.nuance.tts.v1.Text.prototype.clearUri = function() {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.Text.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Text.prototype.hasUri = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.SSML.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.SSML.SsmlDataCase = {
  SSML_DATA_NOT_SET: 0,
  TEXT: 1,
  URI: 2
};

/**
 * @return {proto.nuance.tts.v1.SSML.SsmlDataCase}
 */
proto.nuance.tts.v1.SSML.prototype.getSsmlDataCase = function() {
  return /** @type {proto.nuance.tts.v1.SSML.SsmlDataCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.SSML.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.SSML.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.SSML.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.SSML} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SSML.toObject = function(includeInstance, msg) {
  var f, obj = {
    text: jspb.Message.getFieldWithDefault(msg, 1, ""),
    uri: jspb.Message.getFieldWithDefault(msg, 2, ""),
    ssmlValidationMode: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.SSML}
 */
proto.nuance.tts.v1.SSML.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.SSML;
  return proto.nuance.tts.v1.SSML.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.SSML} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.SSML}
 */
proto.nuance.tts.v1.SSML.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUri(value);
      break;
    case 3:
      var value = /** @type {!proto.nuance.tts.v1.EnumSSMLValidationMode} */ (reader.readEnum());
      msg.setSsmlValidationMode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SSML.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.SSML.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.SSML} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SSML.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSsmlValidationMode();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * optional string text = 1;
 * @return {string}
 */
proto.nuance.tts.v1.SSML.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.SSML} returns this
 */
proto.nuance.tts.v1.SSML.prototype.setText = function(value) {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.SSML.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.SSML} returns this
 */
proto.nuance.tts.v1.SSML.prototype.clearText = function() {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.SSML.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SSML.prototype.hasText = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string uri = 2;
 * @return {string}
 */
proto.nuance.tts.v1.SSML.prototype.getUri = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.SSML} returns this
 */
proto.nuance.tts.v1.SSML.prototype.setUri = function(value) {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.SSML.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.SSML} returns this
 */
proto.nuance.tts.v1.SSML.prototype.clearUri = function() {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.SSML.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SSML.prototype.hasUri = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional EnumSSMLValidationMode ssml_validation_mode = 3;
 * @return {!proto.nuance.tts.v1.EnumSSMLValidationMode}
 */
proto.nuance.tts.v1.SSML.prototype.getSsmlValidationMode = function() {
  return /** @type {!proto.nuance.tts.v1.EnumSSMLValidationMode} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumSSMLValidationMode} value
 * @return {!proto.nuance.tts.v1.SSML} returns this
 */
proto.nuance.tts.v1.SSML.prototype.setSsmlValidationMode = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.TokenizedSequence.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.TokenizedSequence.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.TokenizedSequence.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.TokenizedSequence} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.TokenizedSequence.toObject = function(includeInstance, msg) {
  var f, obj = {
    tokensList: jspb.Message.toObjectList(msg.getTokensList(),
    proto.nuance.tts.v1.Token.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.TokenizedSequence}
 */
proto.nuance.tts.v1.TokenizedSequence.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.TokenizedSequence;
  return proto.nuance.tts.v1.TokenizedSequence.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.TokenizedSequence} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.TokenizedSequence}
 */
proto.nuance.tts.v1.TokenizedSequence.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Token;
      reader.readMessage(value,proto.nuance.tts.v1.Token.deserializeBinaryFromReader);
      msg.addTokens(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.TokenizedSequence.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.TokenizedSequence.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.TokenizedSequence} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.TokenizedSequence.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTokensList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.nuance.tts.v1.Token.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Token tokens = 1;
 * @return {!Array<!proto.nuance.tts.v1.Token>}
 */
proto.nuance.tts.v1.TokenizedSequence.prototype.getTokensList = function() {
  return /** @type{!Array<!proto.nuance.tts.v1.Token>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nuance.tts.v1.Token, 1));
};


/**
 * @param {!Array<!proto.nuance.tts.v1.Token>} value
 * @return {!proto.nuance.tts.v1.TokenizedSequence} returns this
*/
proto.nuance.tts.v1.TokenizedSequence.prototype.setTokensList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.nuance.tts.v1.Token=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.Token}
 */
proto.nuance.tts.v1.TokenizedSequence.prototype.addTokens = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.nuance.tts.v1.Token, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.TokenizedSequence} returns this
 */
proto.nuance.tts.v1.TokenizedSequence.prototype.clearTokensList = function() {
  return this.setTokensList([]);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.Token.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.Token.TokenDataCase = {
  TOKEN_DATA_NOT_SET: 0,
  TEXT: 1,
  CONTROL_CODE: 2
};

/**
 * @return {proto.nuance.tts.v1.Token.TokenDataCase}
 */
proto.nuance.tts.v1.Token.prototype.getTokenDataCase = function() {
  return /** @type {proto.nuance.tts.v1.Token.TokenDataCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.Token.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Token.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Token.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Token} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Token.toObject = function(includeInstance, msg) {
  var f, obj = {
    text: jspb.Message.getFieldWithDefault(msg, 1, ""),
    controlCode: (f = msg.getControlCode()) && proto.nuance.tts.v1.ControlCode.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Token}
 */
proto.nuance.tts.v1.Token.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Token;
  return proto.nuance.tts.v1.Token.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Token} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Token}
 */
proto.nuance.tts.v1.Token.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.ControlCode;
      reader.readMessage(value,proto.nuance.tts.v1.ControlCode.deserializeBinaryFromReader);
      msg.setControlCode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Token.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Token.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Token} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Token.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getControlCode();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.ControlCode.serializeBinaryToWriter
    );
  }
};


/**
 * optional string text = 1;
 * @return {string}
 */
proto.nuance.tts.v1.Token.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Token} returns this
 */
proto.nuance.tts.v1.Token.prototype.setText = function(value) {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.Token.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.Token} returns this
 */
proto.nuance.tts.v1.Token.prototype.clearText = function() {
  return jspb.Message.setOneofField(this, 1, proto.nuance.tts.v1.Token.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Token.prototype.hasText = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ControlCode control_code = 2;
 * @return {?proto.nuance.tts.v1.ControlCode}
 */
proto.nuance.tts.v1.Token.prototype.getControlCode = function() {
  return /** @type{?proto.nuance.tts.v1.ControlCode} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.ControlCode, 2));
};


/**
 * @param {?proto.nuance.tts.v1.ControlCode|undefined} value
 * @return {!proto.nuance.tts.v1.Token} returns this
*/
proto.nuance.tts.v1.Token.prototype.setControlCode = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.nuance.tts.v1.Token.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.Token} returns this
 */
proto.nuance.tts.v1.Token.prototype.clearControlCode = function() {
  return this.setControlCode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.Token.prototype.hasControlCode = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.ControlCode.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.ControlCode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.ControlCode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ControlCode.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: jspb.Message.getFieldWithDefault(msg, 1, ""),
    value: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.ControlCode}
 */
proto.nuance.tts.v1.ControlCode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.ControlCode;
  return proto.nuance.tts.v1.ControlCode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.ControlCode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.ControlCode}
 */
proto.nuance.tts.v1.ControlCode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.ControlCode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.ControlCode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.ControlCode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.ControlCode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string key = 1;
 * @return {string}
 */
proto.nuance.tts.v1.ControlCode.prototype.getKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.ControlCode} returns this
 */
proto.nuance.tts.v1.ControlCode.prototype.setKey = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string value = 2;
 * @return {string}
 */
proto.nuance.tts.v1.ControlCode.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.ControlCode} returns this
 */
proto.nuance.tts.v1.ControlCode.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.SynthesisResource.oneofGroups_ = [[2,3]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.SynthesisResource.ResourceDataCase = {
  RESOURCE_DATA_NOT_SET: 0,
  URI: 2,
  BODY: 3
};

/**
 * @return {proto.nuance.tts.v1.SynthesisResource.ResourceDataCase}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getResourceDataCase = function() {
  return /** @type {proto.nuance.tts.v1.SynthesisResource.ResourceDataCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.SynthesisResource.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.SynthesisResource.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.SynthesisResource} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisResource.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    uri: jspb.Message.getFieldWithDefault(msg, 2, ""),
    body: msg.getBody_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.SynthesisResource}
 */
proto.nuance.tts.v1.SynthesisResource.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.SynthesisResource;
  return proto.nuance.tts.v1.SynthesisResource.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.SynthesisResource} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.SynthesisResource}
 */
proto.nuance.tts.v1.SynthesisResource.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.nuance.tts.v1.EnumResourceType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUri(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBody(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.SynthesisResource.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.SynthesisResource} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisResource.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional EnumResourceType type = 1;
 * @return {!proto.nuance.tts.v1.EnumResourceType}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getType = function() {
  return /** @type {!proto.nuance.tts.v1.EnumResourceType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.nuance.tts.v1.EnumResourceType} value
 * @return {!proto.nuance.tts.v1.SynthesisResource} returns this
 */
proto.nuance.tts.v1.SynthesisResource.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string uri = 2;
 * @return {string}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getUri = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.SynthesisResource} returns this
 */
proto.nuance.tts.v1.SynthesisResource.prototype.setUri = function(value) {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.SynthesisResource.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisResource} returns this
 */
proto.nuance.tts.v1.SynthesisResource.prototype.clearUri = function() {
  return jspb.Message.setOneofField(this, 2, proto.nuance.tts.v1.SynthesisResource.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.hasUri = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes body = 3;
 * @return {!(string|Uint8Array)}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getBody = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes body = 3;
 * This is a type-conversion wrapper around `getBody()`
 * @return {string}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getBody_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBody()));
};


/**
 * optional bytes body = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBody()`
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.getBody_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBody()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.nuance.tts.v1.SynthesisResource} returns this
 */
proto.nuance.tts.v1.SynthesisResource.prototype.setBody = function(value) {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.SynthesisResource.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisResource} returns this
 */
proto.nuance.tts.v1.SynthesisResource.prototype.clearBody = function() {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.SynthesisResource.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisResource.prototype.hasBody = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.LanguageIdentificationParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.LanguageIdentificationParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    disable: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
    languagesList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f,
    alwaysUseHighestConfidence: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.LanguageIdentificationParameters;
  return proto.nuance.tts.v1.LanguageIdentificationParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.LanguageIdentificationParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisable(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addLanguages(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAlwaysUseHighestConfidence(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.LanguageIdentificationParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.LanguageIdentificationParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDisable();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getLanguagesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
  f = message.getAlwaysUseHighestConfidence();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional bool disable = 1;
 * @return {boolean}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.getDisable = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters} returns this
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.setDisable = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * repeated string languages = 2;
 * @return {!Array<string>}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.getLanguagesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters} returns this
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.setLanguagesList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters} returns this
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.addLanguages = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters} returns this
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.clearLanguagesList = function() {
  return this.setLanguagesList([]);
};


/**
 * optional bool always_use_highest_confidence = 3;
 * @return {boolean}
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.getAlwaysUseHighestConfidence = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.LanguageIdentificationParameters} returns this
 */
proto.nuance.tts.v1.LanguageIdentificationParameters.prototype.setAlwaysUseHighestConfidence = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.DownloadParameters.oneofGroups_ = [[3]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.DownloadParameters.OptionalDownloadParameterRequestTimeoutMsCase = {
  OPTIONAL_DOWNLOAD_PARAMETER_REQUEST_TIMEOUT_MS_NOT_SET: 0,
  REQUEST_TIMEOUT_MS: 3
};

/**
 * @return {proto.nuance.tts.v1.DownloadParameters.OptionalDownloadParameterRequestTimeoutMsCase}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.getOptionalDownloadParameterRequestTimeoutMsCase = function() {
  return /** @type {proto.nuance.tts.v1.DownloadParameters.OptionalDownloadParameterRequestTimeoutMsCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.DownloadParameters.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.DownloadParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.DownloadParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.DownloadParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    headersMap: (f = msg.getHeadersMap()) ? f.toObject(includeInstance, undefined) : [],
    refuseCookies: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    requestTimeoutMs: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.DownloadParameters}
 */
proto.nuance.tts.v1.DownloadParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.DownloadParameters;
  return proto.nuance.tts.v1.DownloadParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.DownloadParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.DownloadParameters}
 */
proto.nuance.tts.v1.DownloadParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getHeadersMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRefuseCookies(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequestTimeoutMs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.DownloadParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.DownloadParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.DownloadParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHeadersMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getRefuseCookies();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * map<string, string> headers = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.getHeadersMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nuance.tts.v1.DownloadParameters} returns this
 */
proto.nuance.tts.v1.DownloadParameters.prototype.clearHeadersMap = function() {
  this.getHeadersMap().clear();
  return this;};


/**
 * optional bool refuse_cookies = 2;
 * @return {boolean}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.getRefuseCookies = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.DownloadParameters} returns this
 */
proto.nuance.tts.v1.DownloadParameters.prototype.setRefuseCookies = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional uint32 request_timeout_ms = 3;
 * @return {number}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.getRequestTimeoutMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.DownloadParameters} returns this
 */
proto.nuance.tts.v1.DownloadParameters.prototype.setRequestTimeoutMs = function(value) {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.DownloadParameters.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.DownloadParameters} returns this
 */
proto.nuance.tts.v1.DownloadParameters.prototype.clearRequestTimeoutMs = function() {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.DownloadParameters.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.DownloadParameters.prototype.hasRequestTimeoutMs = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.EventParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.EventParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.EventParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.EventParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    sendSentenceMarkerEvents: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
    sendWordMarkerEvents: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    sendPhonemeMarkerEvents: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    sendBookmarkMarkerEvents: jspb.Message.getBooleanFieldWithDefault(msg, 4, false),
    sendParagraphMarkerEvents: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
    sendVisemes: jspb.Message.getBooleanFieldWithDefault(msg, 6, false),
    sendLogEvents: jspb.Message.getBooleanFieldWithDefault(msg, 7, false),
    suppressInput: jspb.Message.getBooleanFieldWithDefault(msg, 8, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.EventParameters}
 */
proto.nuance.tts.v1.EventParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.EventParameters;
  return proto.nuance.tts.v1.EventParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.EventParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.EventParameters}
 */
proto.nuance.tts.v1.EventParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendSentenceMarkerEvents(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendWordMarkerEvents(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendPhonemeMarkerEvents(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendBookmarkMarkerEvents(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendParagraphMarkerEvents(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendVisemes(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendLogEvents(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSuppressInput(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.EventParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.EventParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.EventParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.EventParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSendSentenceMarkerEvents();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getSendWordMarkerEvents();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getSendPhonemeMarkerEvents();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getSendBookmarkMarkerEvents();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getSendParagraphMarkerEvents();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getSendVisemes();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getSendLogEvents();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
  f = message.getSuppressInput();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
};


/**
 * optional bool send_sentence_marker_events = 1;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendSentenceMarkerEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendSentenceMarkerEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional bool send_word_marker_events = 2;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendWordMarkerEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendWordMarkerEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool send_phoneme_marker_events = 3;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendPhonemeMarkerEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendPhonemeMarkerEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bool send_bookmark_marker_events = 4;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendBookmarkMarkerEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendBookmarkMarkerEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bool send_paragraph_marker_events = 5;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendParagraphMarkerEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 5, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendParagraphMarkerEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional bool send_visemes = 6;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendVisemes = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 6, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendVisemes = function(value) {
  return jspb.Message.setProto3BooleanField(this, 6, value);
};


/**
 * optional bool send_log_events = 7;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSendLogEvents = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 7, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSendLogEvents = function(value) {
  return jspb.Message.setProto3BooleanField(this, 7, value);
};


/**
 * optional bool suppress_input = 8;
 * @return {boolean}
 */
proto.nuance.tts.v1.EventParameters.prototype.getSuppressInput = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 8, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nuance.tts.v1.EventParameters} returns this
 */
proto.nuance.tts.v1.EventParameters.prototype.setSuppressInput = function(value) {
  return jspb.Message.setProto3BooleanField(this, 8, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.nuance.tts.v1.SynthesisResponse.oneofGroups_ = [[1,2,3]];

/**
 * @enum {number}
 */
proto.nuance.tts.v1.SynthesisResponse.ResponseCase = {
  RESPONSE_NOT_SET: 0,
  STATUS: 1,
  EVENTS: 2,
  AUDIO: 3
};

/**
 * @return {proto.nuance.tts.v1.SynthesisResponse.ResponseCase}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getResponseCase = function() {
  return /** @type {proto.nuance.tts.v1.SynthesisResponse.ResponseCase} */(jspb.Message.computeOneofCase(this, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.SynthesisResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.SynthesisResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: (f = msg.getStatus()) && proto.nuance.tts.v1.Status.toObject(includeInstance, f),
    events: (f = msg.getEvents()) && proto.nuance.tts.v1.Events.toObject(includeInstance, f),
    audio: msg.getAudio_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.SynthesisResponse}
 */
proto.nuance.tts.v1.SynthesisResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.SynthesisResponse;
  return proto.nuance.tts.v1.SynthesisResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.SynthesisResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.SynthesisResponse}
 */
proto.nuance.tts.v1.SynthesisResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Status;
      reader.readMessage(value,proto.nuance.tts.v1.Status.deserializeBinaryFromReader);
      msg.setStatus(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.Events;
      reader.readMessage(value,proto.nuance.tts.v1.Events.deserializeBinaryFromReader);
      msg.setEvents(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAudio(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.SynthesisResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.SynthesisResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.SynthesisResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.Status.serializeBinaryToWriter
    );
  }
  f = message.getEvents();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.Events.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional Status status = 1;
 * @return {?proto.nuance.tts.v1.Status}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getStatus = function() {
  return /** @type{?proto.nuance.tts.v1.Status} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Status, 1));
};


/**
 * @param {?proto.nuance.tts.v1.Status|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
*/
proto.nuance.tts.v1.SynthesisResponse.prototype.setStatus = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.clearStatus = function() {
  return this.setStatus(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.hasStatus = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Events events = 2;
 * @return {?proto.nuance.tts.v1.Events}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getEvents = function() {
  return /** @type{?proto.nuance.tts.v1.Events} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Events, 2));
};


/**
 * @param {?proto.nuance.tts.v1.Events|undefined} value
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
*/
proto.nuance.tts.v1.SynthesisResponse.prototype.setEvents = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.clearEvents = function() {
  return this.setEvents(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.hasEvents = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes audio = 3;
 * @return {!(string|Uint8Array)}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getAudio = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes audio = 3;
 * This is a type-conversion wrapper around `getAudio()`
 * @return {string}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getAudio_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAudio()));
};


/**
 * optional bytes audio = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAudio()`
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.getAudio_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAudio()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.setAudio = function(value) {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nuance.tts.v1.SynthesisResponse} returns this
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.clearAudio = function() {
  return jspb.Message.setOneofField(this, 3, proto.nuance.tts.v1.SynthesisResponse.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.SynthesisResponse.prototype.hasAudio = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.UnarySynthesisResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.UnarySynthesisResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.UnarySynthesisResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: (f = msg.getStatus()) && proto.nuance.tts.v1.Status.toObject(includeInstance, f),
    events: (f = msg.getEvents()) && proto.nuance.tts.v1.Events.toObject(includeInstance, f),
    audio: msg.getAudio_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.UnarySynthesisResponse;
  return proto.nuance.tts.v1.UnarySynthesisResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.UnarySynthesisResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Status;
      reader.readMessage(value,proto.nuance.tts.v1.Status.deserializeBinaryFromReader);
      msg.setStatus(value);
      break;
    case 2:
      var value = new proto.nuance.tts.v1.Events;
      reader.readMessage(value,proto.nuance.tts.v1.Events.deserializeBinaryFromReader);
      msg.setEvents(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAudio(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.UnarySynthesisResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.UnarySynthesisResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.UnarySynthesisResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nuance.tts.v1.Status.serializeBinaryToWriter
    );
  }
  f = message.getEvents();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nuance.tts.v1.Events.serializeBinaryToWriter
    );
  }
  f = message.getAudio_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional Status status = 1;
 * @return {?proto.nuance.tts.v1.Status}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.getStatus = function() {
  return /** @type{?proto.nuance.tts.v1.Status} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Status, 1));
};


/**
 * @param {?proto.nuance.tts.v1.Status|undefined} value
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse} returns this
*/
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.setStatus = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse} returns this
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.clearStatus = function() {
  return this.setStatus(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.hasStatus = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Events events = 2;
 * @return {?proto.nuance.tts.v1.Events}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.getEvents = function() {
  return /** @type{?proto.nuance.tts.v1.Events} */ (
    jspb.Message.getWrapperField(this, proto.nuance.tts.v1.Events, 2));
};


/**
 * @param {?proto.nuance.tts.v1.Events|undefined} value
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse} returns this
*/
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.setEvents = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse} returns this
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.clearEvents = function() {
  return this.setEvents(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.hasEvents = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes audio = 3;
 * @return {!(string|Uint8Array)}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.getAudio = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes audio = 3;
 * This is a type-conversion wrapper around `getAudio()`
 * @return {string}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.getAudio_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAudio()));
};


/**
 * optional bytes audio = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAudio()`
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.getAudio_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAudio()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.nuance.tts.v1.UnarySynthesisResponse} returns this
 */
proto.nuance.tts.v1.UnarySynthesisResponse.prototype.setAudio = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Status.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Status.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Status} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Status.toObject = function(includeInstance, msg) {
  var f, obj = {
    code: jspb.Message.getFieldWithDefault(msg, 1, 0),
    message: jspb.Message.getFieldWithDefault(msg, 2, ""),
    details: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Status}
 */
proto.nuance.tts.v1.Status.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Status;
  return proto.nuance.tts.v1.Status.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Status} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Status}
 */
proto.nuance.tts.v1.Status.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Status.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Status.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Status} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Status.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCode();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getDetails();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional uint32 code = 1;
 * @return {number}
 */
proto.nuance.tts.v1.Status.prototype.getCode = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.nuance.tts.v1.Status} returns this
 */
proto.nuance.tts.v1.Status.prototype.setCode = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.nuance.tts.v1.Status.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Status} returns this
 */
proto.nuance.tts.v1.Status.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string details = 3;
 * @return {string}
 */
proto.nuance.tts.v1.Status.prototype.getDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Status} returns this
 */
proto.nuance.tts.v1.Status.prototype.setDetails = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nuance.tts.v1.Events.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Events.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Events.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Events} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Events.toObject = function(includeInstance, msg) {
  var f, obj = {
    eventsList: jspb.Message.toObjectList(msg.getEventsList(),
    proto.nuance.tts.v1.Event.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Events}
 */
proto.nuance.tts.v1.Events.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Events;
  return proto.nuance.tts.v1.Events.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Events} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Events}
 */
proto.nuance.tts.v1.Events.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nuance.tts.v1.Event;
      reader.readMessage(value,proto.nuance.tts.v1.Event.deserializeBinaryFromReader);
      msg.addEvents(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Events.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Events.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Events} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Events.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEventsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.nuance.tts.v1.Event.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Event events = 1;
 * @return {!Array<!proto.nuance.tts.v1.Event>}
 */
proto.nuance.tts.v1.Events.prototype.getEventsList = function() {
  return /** @type{!Array<!proto.nuance.tts.v1.Event>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nuance.tts.v1.Event, 1));
};


/**
 * @param {!Array<!proto.nuance.tts.v1.Event>} value
 * @return {!proto.nuance.tts.v1.Events} returns this
*/
proto.nuance.tts.v1.Events.prototype.setEventsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.nuance.tts.v1.Event=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nuance.tts.v1.Event}
 */
proto.nuance.tts.v1.Events.prototype.addEvents = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.nuance.tts.v1.Event, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nuance.tts.v1.Events} returns this
 */
proto.nuance.tts.v1.Events.prototype.clearEventsList = function() {
  return this.setEventsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nuance.tts.v1.Event.prototype.toObject = function(opt_includeInstance) {
  return proto.nuance.tts.v1.Event.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nuance.tts.v1.Event} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Event.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
    valuesMap: (f = msg.getValuesMap()) ? f.toObject(includeInstance, undefined) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nuance.tts.v1.Event}
 */
proto.nuance.tts.v1.Event.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nuance.tts.v1.Event;
  return proto.nuance.tts.v1.Event.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nuance.tts.v1.Event} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nuance.tts.v1.Event}
 */
proto.nuance.tts.v1.Event.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = msg.getValuesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nuance.tts.v1.Event.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nuance.tts.v1.Event.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nuance.tts.v1.Event} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nuance.tts.v1.Event.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getValuesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nuance.tts.v1.Event.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nuance.tts.v1.Event} returns this
 */
proto.nuance.tts.v1.Event.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * map<string, string> values = 2;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.nuance.tts.v1.Event.prototype.getValuesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 2, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nuance.tts.v1.Event} returns this
 */
proto.nuance.tts.v1.Event.prototype.clearValuesMap = function() {
  this.getValuesMap().clear();
  return this;};


/**
 * @enum {number}
 */
proto.nuance.tts.v1.EnumAgeGroup = {
  ADULT: 0,
  CHILD: 1
};

/**
 * @enum {number}
 */
proto.nuance.tts.v1.EnumGender = {
  ANY: 0,
  MALE: 1,
  FEMALE: 2,
  NEUTRAL: 3
};

/**
 * @enum {number}
 */
proto.nuance.tts.v1.EnumVariableBitrate = {
  VARIABLE_BITRATE_ON: 0,
  VARIABLE_BITRATE_OFF: 1,
  VARIABLE_BITRATE_CONSTRAINED: 2
};

/**
 * @enum {number}
 */
proto.nuance.tts.v1.EnumResourceType = {
  USER_DICTIONARY: 0,
  TEXT_USER_RULESET: 1,
  BINARY_USER_RULESET: 2,
  ACTIVEPROMPT_DB: 3,
  ACTIVEPROMPT_DB_AUTO: 4,
  SYSTEM_DICTIONARY: 5
};

/**
 * @enum {number}
 */
proto.nuance.tts.v1.EnumSSMLValidationMode = {
  STRICT: 0,
  WARN: 1,
  NONE: 2
};

goog.object.extend(exports, proto.nuance.tts.v1);
